IPC（进程间通信）InterProcess Communication

进程间通信机制主要有：
（1）管道、有名管道
（2）信号
（3）消息队列
（4）共享内存
（5）信号量
（6）套接字(socket)

本机使用（不能跨机器）：管道
pipe 和 FIFO 用来实现进程间互相发送非常短小的、频率很高的消息；这两种方式通常适用于两个进程间的通信。
共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据（配合信号量使用）；

1. 管道
管道是单向的、先进先出的、无结构的字节流，它把一个进程的输出和另一个进程的输入连接在一起。
- 写进程在管道的尾端写入数据，读进程在管道的首端读出数据。
- 管道提供了简单的流控制机制。进程试图读一个空管道时，在数据写入管道前，进程将一直阻塞。同样，管道已经满时，进程再视图写管道，在其他进程从管道中读走数据之前，写进程将一直阻塞。

特点：
- 只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）
Unamed pipes can be used only between related process when a common ancestor has created the pipe.
- 一种半双工的通信模式，具有固定的读端和写端。
- LINUX 把管道看做是一种文件，采用文件管理的方法对管道进行管理，对于它的读写也可以使用普通的read() 和 write() 等函数。但是它不是普通的文件，并不属于其他任何文件系统，只存在于内核的内存空间中。
- 管道容量为 64KB
- 必须在系统调用 fork() 前调用 pipe()，否则子进程将不会继承文件描述符。

管道的创建与关闭
- 管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fd[0]和fd[1]
fd[0]固定用于读管道
fd[1]固定用于写管道
- 管道的关闭只需将这两个文件描述符关闭即可，可使用普通的 close() 函数逐个关闭各个文件描述符。

管道创建函数

pipe()

fd[0] 用来读取数据，fd[1] 用来写入数据

int fd[2];
int pid;

if(pipe(fd)<0) {
	printf("pipe error")	
}

pid = fork();
if (父进程) {
	
} else {
	// 子进程
}

pipe 的限制有两个：
1）只支持单向数据流
2）只能用于具有亲缘关系的进程之间通信，没有名字
3) 缓冲区有限，管道只存在于主存中，大小为一个页面
4) 所传送的是无格式字节流


2. FIFO(First In First Out)，又称为有名管道（named pipe）
有名管道也被称为 FIFO 文件，是一种特殊的文件。

有名管道的创建和关闭
- 创建 mkfifo、mknod 

创建之后需要 open 才能使用
- 阻塞读、非阻塞读、阻塞写、非阻塞写 （注意不能以读写方式打开）

特点：
1. 可以用于运行于同一系统中的任意两个进程间的通信
2. 可以有多个读/写进程同时对管道进行操作
3. 可以像变通文件一样管理管道的权限


=================== 信号(signal) ================
信号是在软件层次上对中断机制的一种模拟，信号是进程间通信机制中唯一的异步通信机制。
信号来源：
1）硬件来源（比如我们按下了键盘或者其他硬件故障）
2）软件来源，最常用发送信号的系统函数时 kill，raise，alarm 和 setitimer 以及 sigqueue 函数，软件来源还包括一些非法运算等操作。

一个完整的信号周期包括三个部分：
1）信号的产生(软件和硬件两种途径)
2）信号在进程中的注册 signal signalaction
进程表的表项中有一个软中断信号域，该域中每一位对应一个信号。内核给一个进程发送软终端信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。
进程的 task_struct 结构中有关于本进程中未决信号的数据成员：
struct sigpending{

        struct sigqueue *head, *tail;

        sigset_t signal;

};

实时信号，不管该信号是否已经在进程中注册，都会被再注册一次。
非实时信号，如果该信号已经在进程中注册，则该信号讲被丢弃。

3）信号在进程中的注销，执行信号处理函数

内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当其由于被信号唤醒或者正常调度重新获得CPU时，在其从内核空间返回到用户空间时会检测是否有信号等待处理。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉。

当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。

内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。

处理信号有三种类型：进程接收到信号后退出；进程忽略该信号；进程收到信号后执行用户设定用系统调用signal的函数。

信号发送函数
kill(), sigqueue(), raise(), alarm(), setitimer(), pause()，abort()
信号安装函数
signal(), sigaction()
信号集操作函数
sigemptyset(), sigfillset(), sigaddset(), sigdelset(), sigismember()

当信号发生时，调用的函数称为 信号处理函数（signal handler）或者信号捕捉函数（signal-catching function）

- 当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像，所以信号捕捉函数的地址在子进程中时有意义的。

- 可重入函数
一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另外一段代码，而返回控制时不会出现什么错误。而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被终端的话，可能会出现问题，这类函数是不能运行在多任务环境下的。
编写可重入函数时，若使用全局变量，则应通过关终端、信号量（即 P、V 操作）等手段对其加以保护。

- 在现代的分布式系统中，通常都是消息驱动: 即进程受到某个消息后，通过对消息的内容的分析然后做相应的动作。如果你把你的分布式系统设置成信号驱动的，这就表示你受到一个信号要做一个动作而一个信号的本质其实就是一个数字而已。这样系统稍微大一点的话，系统将变得异常难以维护；甚至在很多时候，信号驱动是无法满足我们的需求的。

void (*signal(int sig, void (*func)(int)))(int); 

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

void 
int_handler(int signum) {
    printf("\nSIGINT signal handler.\n");
    printf("exit.\n");
    exit(0);
}

int 
main() {
    signal(SIGINT, int_handler);
    printf("int_handler set for SIGINT\n");
    while(1) {
        printf("go to sleep.\n");
        sleep(60);
    }   
    return 0;
}

=========== （4）消息队列 ===========
https://blog.csdn.net/zhanghuaichao/article/details/53242057
消息队列是什么？
消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

如何使用消息队列？

创建和访问一个消息队列
int msgget(key_t key, int msgflg);  
msgflg 是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。msgflag可以与IPC_CREAT做或操作，表示当 key 所命名的消息队列不存在时创建一个消息队列。

把消息添加到消息队列中
int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); 

从一个消息队列获取消息
int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);

控制消息队列
int msgctl(int msgid, int command, struct msgid_ds *buf);

demo：

消息队列与命名管道

它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据又 write，接收数据用 read，则在消息队列中，发送数据用 msgsnd，接收数据用 msgrcv。

优势：
1. 消息队列可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。
2. 消息队列发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。
3. 接收程序可以通过消息类型有选择地接收数据，而不像是命名管道中那样，只能默认接收。



=========== （5）信号量 =============

信号量与已经介绍过的 IPC 机构（管道、FIFO 以及消息队列）不同，它是一个计数器，用于为多个进程提供对共享数据对象的访问。
sem_wait 函数，如果信号量计数是 0 就会发生阻塞，直到成功使信号量减 1 或者被信号中断时才返回。可以使用 sem_trywait 函数来避免阻塞。调用 sem_trywait 时，如果信号量是 0，则不会阻塞，而是返回 -1 并且将 errno 置为 EAGAIN。

set_post 函数使信号量值增 1.

对信号量的理解：
- 信号量就是在一个叫做互斥区的门口放一个盒子，里面装着固定数量的小球，每个线程过来的时候，都在盒子里摸走一个小球，然后去互斥区操作，操作完成，再把小球放回盒子里。如果一个线程过来一摸盒子，一个球都没有了，就得在门口等一个线程出来放球。那么互斥区里面的最大线程数量就是固定的，不会出现一下子进去太多线程把互斥区给挤爆了的情况，这是用信号量做并发量的限制。
- 另外一些情况下，小球是一次性的，线程拿走一个进了门，然后把小球丢了，有一个生产者往盒子里加球，线程来消费掉。就是生产者-消费者模型。

对比：
互斥锁、信号量的区别

信号量是比互斥锁更加高级的同步机制，mutex 可以说是 信号量在仅取值 0/1 的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。
但是 mutex 比 信号量 更加严格，一个线程获得一个锁后，其余线程均不能释放该锁，只能由获取锁的线程释放锁。但是信号量可以做到一个线程获取一个锁，其他线程同样可以释放该锁。


#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

static int balance = 0;
sem_t *s;

void *
deposit(void *args) {
    sem_wait(s);
    balance += 10;
    sem_post(s);
    return NULL;
}

void *
withdrawal(void *args) {
    sem_wait(s);
    balance -= 10;
    sem_post(s);
    return NULL;
}

void
multiThread(void) {
    int n = 10000;
    pthread_t tid1[n];
    pthread_t tid2[n];
    for (int i = 0; i < n; i++) {
        pthread_create(&tid1[i], NULL, deposit, NULL);
        pthread_create(&tid2[i], NULL, withdrawal, NULL);
    }
    for (int i = 0; i < n; i++) {
        pthread_join(tid1[i], NULL);
        pthread_join(tid2[i], NULL);
    }
}

int
main(void) {
    const char c = 'c';
    s = sem_open(&c, O_CREAT, 0644, 1); // 1 为初始的信号量值。
    multiThread();

    printf("main end, %d\n", balance);
    return 0;
}




